\doxysection{Sg\+Command Class Reference}
\hypertarget{class_sg_command}{}\label{class_sg_command}\index{SgCommand@{SgCommand}}
Inheritance diagram for Sg\+Command\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{class_sg_command}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{class_sg_command_ae38b00bb1c2a4dc9ec98e685ff518867}{Extract\+Key\+Info}} (std\+::shared\+\_\+ptr$<$ Key $>$ \&p\+Key)
\begin{DoxyCompactList}\small\item\em Extract the information of a key. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_sg_command_a739ee30cca6dc7ce8bde7d80984e0ded}{Generate\+RSAKeys}} (Key\+Size key\+Size, const std\+::vector$<$ std\+::shared\+\_\+ptr$<$ Container $>$ $>$ \&p\+Containers, unsigned int \&key\+Id\+Generated)
\begin{DoxyCompactList}\small\item\em Generate a pair of keys. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_sg_command_a9836c66bc24dc6a3a2779d9b4f9b0b79}{Delete\+Dedicated\+File\+Private\+Key}} (BYTE key\+Reference, BYTE file\+Name)
\begin{DoxyCompactList}\small\item\em Delete the file of a private key. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_sg_command_a6f8d8dfbcdb24036e9d8cb3d70c61f2c}{Delete\+Dedicated\+File\+Public\+Key}} (BYTE key\+Reference, BYTE file\+Name)
\begin{DoxyCompactList}\small\item\em Delete the file of a public key. \end{DoxyCompactList}\item 
uint32\+\_\+t \mbox{\hyperlink{class_sg_command_aca5ee6e7312036448e0527baadab4368}{Counting\+Private\+Keys}} ()
\begin{DoxyCompactList}\small\item\em Count the total of private keys. \end{DoxyCompactList}\item 
uint32\+\_\+t \mbox{\hyperlink{class_sg_command_a5234a9aa07ece47a8c0b487c027ebed1}{Counting\+Public\+Keys}} ()
\begin{DoxyCompactList}\small\item\em Delete the file of a public key. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_sg_command_aab4a3a1224916b9e660616e3ca8161e3}{Delete\+Dedicated\+File\+Certificate}} (BYTE certificate\+Reference, BYTE file\+Name)
\begin{DoxyCompactList}\small\item\em Delete the file of a certificate. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_sg_command_a4999b704735bf8e5a256f5b351683251}{Get\+Certificate\+Application\+Data}} ()
\begin{DoxyCompactList}\small\item\em Get the application data of a certificate. \end{DoxyCompactList}\item 
BYTE \mbox{\hyperlink{class_sg_command_afd218d96a24fb0db3e382f5ee0ea264b}{Get\+Certificate\+Empty\+File\+Name}} (std\+::vector$<$ std\+::shared\+\_\+ptr$<$ Container $>$ $>$ \&containers)
\begin{DoxyCompactList}\small\item\em Get empty file names for certificates. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_sg_command_afc5188c353d2b922d71c9c2c1060a8f2}{Write\+Last\+Descriptor\+Certificate}} (const std\+::string r\+Folder\+Name, BYTE certificate\+Reference, std\+::vector$<$ BYTE $>$ UUID, uint32\+\_\+t cert\+Len)
\begin{DoxyCompactList}\small\item\em Write a certificate file into a folder. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_sg_command_ae01ea3cedaa6a3bd8cb830d358f3cd94}{Get\+Certificate}} (std\+::vector$<$ BYTE $>$ \&certificate, BYTE certificate\+Reference)
\begin{DoxyCompactList}\small\item\em Reads a certificate file. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_sg_command_a35f6f3cdd8b86d3e2fc0d75419c243c9}{Write\+Current\+Selected\+File}} (const std\+::vector$<$ BYTE $>$ \&r\+File)
\begin{DoxyCompactList}\small\item\em Write a file to a card. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_sg_command_a48f8f62bb85fa3fbe51a26bdd3c2d120}{Create\+Empty\+Certificate}} (const unsigned int \&r\+Size\+Certificate, BYTE certificate\+Reference)
\begin{DoxyCompactList}\small\item\em Creates an empty certificate. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::shared\+\_\+ptr$<$ Certificate $>$ $>$ \mbox{\hyperlink{class_sg_command_a639c9c46742ad989126b792e9a25ba85}{Get\+Certificates}} ()
\begin{DoxyCompactList}\small\item\em Get existing certificates. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ Container $>$ \mbox{\hyperlink{class_sg_command_acbe54f58b6d971587e7592fd4bc450d0}{Get\+Container\+Info}} (const BYTE \&number\+Container, std\+::vector$<$ std\+::shared\+\_\+ptr$<$ Certificate $>$ $>$ certificates)
\begin{DoxyCompactList}\small\item\em Get the information of a specified container. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Member Function Documentation}
\Hypertarget{class_sg_command_aca5ee6e7312036448e0527baadab4368}\label{class_sg_command_aca5ee6e7312036448e0527baadab4368} 
\index{SgCommand@{SgCommand}!CountingPrivateKeys@{CountingPrivateKeys}}
\index{CountingPrivateKeys@{CountingPrivateKeys}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{CountingPrivateKeys()}{CountingPrivateKeys()}}
{\footnotesize\ttfamily uint32\+\_\+t Sg\+Command\+::\+Counting\+Private\+Keys (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Count the total of private keys. 

\begin{DoxyReturn}{Returns}
integer Total of private keys 
\end{DoxyReturn}
\Hypertarget{class_sg_command_a5234a9aa07ece47a8c0b487c027ebed1}\label{class_sg_command_a5234a9aa07ece47a8c0b487c027ebed1} 
\index{SgCommand@{SgCommand}!CountingPublicKeys@{CountingPublicKeys}}
\index{CountingPublicKeys@{CountingPublicKeys}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{CountingPublicKeys()}{CountingPublicKeys()}}
{\footnotesize\ttfamily uint32\+\_\+t Sg\+Command\+::\+Counting\+Public\+Keys (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Delete the file of a public key. 

\begin{DoxyReturn}{Returns}
integer Total of public keys 
\end{DoxyReturn}
\Hypertarget{class_sg_command_a48f8f62bb85fa3fbe51a26bdd3c2d120}\label{class_sg_command_a48f8f62bb85fa3fbe51a26bdd3c2d120} 
\index{SgCommand@{SgCommand}!CreateEmptyCertificate@{CreateEmptyCertificate}}
\index{CreateEmptyCertificate@{CreateEmptyCertificate}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{CreateEmptyCertificate()}{CreateEmptyCertificate()}}
{\footnotesize\ttfamily bool Sg\+Command\+::\+Create\+Empty\+Certificate (\begin{DoxyParamCaption}\item[{const unsigned int \&}]{r\+Size\+Certificate,  }\item[{BYTE}]{certificate\+Reference }\end{DoxyParamCaption})}



Creates an empty certificate. 


\begin{DoxyParams}{Parameters}
{\em r\+Size\+Certificate} & The size of the certificate \\
\hline
{\em certificate\+Reference} & The refeference to where the certificate will be created \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool Signaling if the creation of the certificate was successful 
\end{DoxyReturn}
\Hypertarget{class_sg_command_aab4a3a1224916b9e660616e3ca8161e3}\label{class_sg_command_aab4a3a1224916b9e660616e3ca8161e3} 
\index{SgCommand@{SgCommand}!DeleteDedicatedFileCertificate@{DeleteDedicatedFileCertificate}}
\index{DeleteDedicatedFileCertificate@{DeleteDedicatedFileCertificate}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{DeleteDedicatedFileCertificate()}{DeleteDedicatedFileCertificate()}}
{\footnotesize\ttfamily bool Sg\+Command\+::\+Delete\+Dedicated\+File\+Certificate (\begin{DoxyParamCaption}\item[{BYTE}]{certificate\+Reference,  }\item[{BYTE}]{file\+Name }\end{DoxyParamCaption})}



Delete the file of a certificate. 


\begin{DoxyParams}{Parameters}
{\em certificate\+Reference} & The certificate that will be deleted \\
\hline
{\em file\+Name} & The name of the file associated with the certificate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A bool signaling if the deletion was successful 
\end{DoxyReturn}
\Hypertarget{class_sg_command_a9836c66bc24dc6a3a2779d9b4f9b0b79}\label{class_sg_command_a9836c66bc24dc6a3a2779d9b4f9b0b79} 
\index{SgCommand@{SgCommand}!DeleteDedicatedFilePrivateKey@{DeleteDedicatedFilePrivateKey}}
\index{DeleteDedicatedFilePrivateKey@{DeleteDedicatedFilePrivateKey}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{DeleteDedicatedFilePrivateKey()}{DeleteDedicatedFilePrivateKey()}}
{\footnotesize\ttfamily bool Sg\+Command\+::\+Delete\+Dedicated\+File\+Private\+Key (\begin{DoxyParamCaption}\item[{BYTE}]{key\+Reference,  }\item[{BYTE}]{file\+Name }\end{DoxyParamCaption})}



Delete the file of a private key. 


\begin{DoxyParams}{Parameters}
{\em key\+Reference} & The key that will be deleted \\
\hline
{\em file\+Name} & The name of the file associated with the key \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A bool signaling if the deletion was successful 
\end{DoxyReturn}
\Hypertarget{class_sg_command_a6f8d8dfbcdb24036e9d8cb3d70c61f2c}\label{class_sg_command_a6f8d8dfbcdb24036e9d8cb3d70c61f2c} 
\index{SgCommand@{SgCommand}!DeleteDedicatedFilePublicKey@{DeleteDedicatedFilePublicKey}}
\index{DeleteDedicatedFilePublicKey@{DeleteDedicatedFilePublicKey}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{DeleteDedicatedFilePublicKey()}{DeleteDedicatedFilePublicKey()}}
{\footnotesize\ttfamily bool Sg\+Command\+::\+Delete\+Dedicated\+File\+Public\+Key (\begin{DoxyParamCaption}\item[{BYTE}]{key\+Reference,  }\item[{BYTE}]{file\+Name }\end{DoxyParamCaption})}



Delete the file of a public key. 


\begin{DoxyParams}{Parameters}
{\em key\+Reference} & The key that will be deleted \\
\hline
{\em file\+Name} & The name of the file associated with the key \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A bool signaling if the deletion was successful 
\end{DoxyReturn}
\Hypertarget{class_sg_command_ae38b00bb1c2a4dc9ec98e685ff518867}\label{class_sg_command_ae38b00bb1c2a4dc9ec98e685ff518867} 
\index{SgCommand@{SgCommand}!ExtractKeyInfo@{ExtractKeyInfo}}
\index{ExtractKeyInfo@{ExtractKeyInfo}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{ExtractKeyInfo()}{ExtractKeyInfo()}}
{\footnotesize\ttfamily bool Sg\+Command\+::\+Extract\+Key\+Info (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ Key $>$ \&}]{p\+Key }\end{DoxyParamCaption})}



Extract the information of a key. 


\begin{DoxyParams}{Parameters}
{\em pkey} & The reference to a key \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A bool signaling if the operation was successful 
\end{DoxyReturn}
\Hypertarget{class_sg_command_a739ee30cca6dc7ce8bde7d80984e0ded}\label{class_sg_command_a739ee30cca6dc7ce8bde7d80984e0ded} 
\index{SgCommand@{SgCommand}!GenerateRSAKeys@{GenerateRSAKeys}}
\index{GenerateRSAKeys@{GenerateRSAKeys}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{GenerateRSAKeys()}{GenerateRSAKeys()}}
{\footnotesize\ttfamily bool Sg\+Command\+::\+Generate\+RSAKeys (\begin{DoxyParamCaption}\item[{Key\+Size}]{key\+Size,  }\item[{const std\+::vector$<$ std\+::shared\+\_\+ptr$<$ Container $>$ $>$ \&}]{p\+Containers,  }\item[{unsigned int \&}]{key\+Id\+Generated }\end{DoxyParamCaption})}



Generate a pair of keys. 


\begin{DoxyParams}{Parameters}
{\em key\+Size} & The size of the keys to generate \\
\hline
{\em p\+Containers} & The reference to a vector of pointers to Container objects \\
\hline
{\em key\+Id\+Generated} & The reference to the id of the public key generated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A bool signaling if the operation was successful 
\end{DoxyReturn}
\Hypertarget{class_sg_command_ae01ea3cedaa6a3bd8cb830d358f3cd94}\label{class_sg_command_ae01ea3cedaa6a3bd8cb830d358f3cd94} 
\index{SgCommand@{SgCommand}!GetCertificate@{GetCertificate}}
\index{GetCertificate@{GetCertificate}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{GetCertificate()}{GetCertificate()}}
{\footnotesize\ttfamily bool Sg\+Command\+::\+Get\+Certificate (\begin{DoxyParamCaption}\item[{std\+::vector$<$ BYTE $>$ \&}]{certificate,  }\item[{BYTE}]{certificate\+Reference }\end{DoxyParamCaption})}



Reads a certificate file. 


\begin{DoxyParams}{Parameters}
{\em certficiate} & A reference to a vector of BYTEs \\
\hline
{\em certificate\+Reference} & The reference of a certificate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool Signaling if the operation was successful 
\end{DoxyReturn}
\Hypertarget{class_sg_command_a4999b704735bf8e5a256f5b351683251}\label{class_sg_command_a4999b704735bf8e5a256f5b351683251} 
\index{SgCommand@{SgCommand}!GetCertificateApplicationData@{GetCertificateApplicationData}}
\index{GetCertificateApplicationData@{GetCertificateApplicationData}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{GetCertificateApplicationData()}{GetCertificateApplicationData()}}
{\footnotesize\ttfamily bool Sg\+Command\+::\+Get\+Certificate\+Application\+Data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the application data of a certificate. 

\begin{DoxyReturn}{Returns}
A bool signaling if the operation was successful 
\end{DoxyReturn}
\Hypertarget{class_sg_command_afd218d96a24fb0db3e382f5ee0ea264b}\label{class_sg_command_afd218d96a24fb0db3e382f5ee0ea264b} 
\index{SgCommand@{SgCommand}!GetCertificateEmptyFileName@{GetCertificateEmptyFileName}}
\index{GetCertificateEmptyFileName@{GetCertificateEmptyFileName}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{GetCertificateEmptyFileName()}{GetCertificateEmptyFileName()}}
{\footnotesize\ttfamily BYTE Sg\+Command\+::\+Get\+Certificate\+Empty\+File\+Name (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::shared\+\_\+ptr$<$ Container $>$ $>$ \&}]{containers }\end{DoxyParamCaption})}



Get empty file names for certificates. 


\begin{DoxyParams}{Parameters}
{\em containers} & A reference to a vector of pointers of containers \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
BYTE A file name 
\end{DoxyReturn}
\Hypertarget{class_sg_command_a639c9c46742ad989126b792e9a25ba85}\label{class_sg_command_a639c9c46742ad989126b792e9a25ba85} 
\index{SgCommand@{SgCommand}!GetCertificates@{GetCertificates}}
\index{GetCertificates@{GetCertificates}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{GetCertificates()}{GetCertificates()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::shared\+\_\+ptr$<$ Certificate $>$ $>$ Sg\+Command\+::\+Get\+Certificates (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get existing certificates. 

\begin{DoxyReturn}{Returns}
std\+::vector$<$std\+::shared\+\_\+ptr$<$\+Certificate$>$$>$ The vector of pointers to existing certificates 
\end{DoxyReturn}
\Hypertarget{class_sg_command_acbe54f58b6d971587e7592fd4bc450d0}\label{class_sg_command_acbe54f58b6d971587e7592fd4bc450d0} 
\index{SgCommand@{SgCommand}!GetContainerInfo@{GetContainerInfo}}
\index{GetContainerInfo@{GetContainerInfo}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{GetContainerInfo()}{GetContainerInfo()}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$ Container $>$ Sg\+Command\+::\+Get\+Container\+Info (\begin{DoxyParamCaption}\item[{const BYTE \&}]{number\+Container,  }\item[{std\+::vector$<$ std\+::shared\+\_\+ptr$<$ Certificate $>$ $>$}]{certificates }\end{DoxyParamCaption})}



Get the information of a specified container. 


\begin{DoxyParams}{Parameters}
{\em number\+Container} & The container to get \\
\hline
{\em certificates} & A vector of pointers to certificates where the certificate associated with the container will be looked up \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::shared\+\_\+ptr$<$\+Container$>$ A pointer to the specified container to existing certificates 
\end{DoxyReturn}
\Hypertarget{class_sg_command_a35f6f3cdd8b86d3e2fc0d75419c243c9}\label{class_sg_command_a35f6f3cdd8b86d3e2fc0d75419c243c9} 
\index{SgCommand@{SgCommand}!WriteCurrentSelectedFile@{WriteCurrentSelectedFile}}
\index{WriteCurrentSelectedFile@{WriteCurrentSelectedFile}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{WriteCurrentSelectedFile()}{WriteCurrentSelectedFile()}}
{\footnotesize\ttfamily bool Sg\+Command\+::\+Write\+Current\+Selected\+File (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ BYTE $>$ \&}]{r\+File }\end{DoxyParamCaption})}



Write a file to a card. 


\begin{DoxyParams}{Parameters}
{\em r\+File} & A reference to the file being written \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool Signaling if the writing was successful 
\end{DoxyReturn}
\Hypertarget{class_sg_command_afc5188c353d2b922d71c9c2c1060a8f2}\label{class_sg_command_afc5188c353d2b922d71c9c2c1060a8f2} 
\index{SgCommand@{SgCommand}!WriteLastDescriptorCertificate@{WriteLastDescriptorCertificate}}
\index{WriteLastDescriptorCertificate@{WriteLastDescriptorCertificate}!SgCommand@{SgCommand}}
\doxysubsubsection{\texorpdfstring{WriteLastDescriptorCertificate()}{WriteLastDescriptorCertificate()}}
{\footnotesize\ttfamily bool Sg\+Command\+::\+Write\+Last\+Descriptor\+Certificate (\begin{DoxyParamCaption}\item[{const std\+::string}]{r\+Folder\+Name,  }\item[{BYTE}]{certificate\+Reference,  }\item[{std\+::vector$<$ BYTE $>$}]{UUID,  }\item[{uint32\+\_\+t}]{cert\+Len }\end{DoxyParamCaption})}



Write a certificate file into a folder. 


\begin{DoxyParams}{Parameters}
{\em r\+Folder\+Name} & A reference to the name of the folder where the certificate file will be written \\
\hline
{\em certificate\+Reference} & The reference of a certificate \\
\hline
{\em UUID} & A vector of BYTEs \\
\hline
{\em cert\+Len} & The lenght of the certificate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool Signaling if the operation was successful 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Sg\+SCLib/include/\mbox{\hyperlink{_sg_command_8h}{Sg\+Command.\+h}}\end{DoxyCompactItemize}
